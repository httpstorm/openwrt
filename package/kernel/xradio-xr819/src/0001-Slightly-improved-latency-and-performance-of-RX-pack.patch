From e6d67fe4764da672a436503cdcf0a4dbbd0876c5 Mon Sep 17 00:00:00 2001
From: Georgi Valkov <gvalkov@abv.bg>
Date: Sun, 21 Mar 2021 09:46:42 +0200
Subject: [PATCH] Slightly improved latency and performance of RX packets

Dymanically decrease the sleep time when waiting for interrupts
from the radio, to reduce latency during active communication.
This helps, because we are missing some interrupts.

Print an error when xradio,xr819 is not found in DTS, which
results in running without any interrupts.

Reduce the number of xradio_bh_rx_availlen() calls, because when
called too often we are getting an error:
sunxi-mmc 1c10000.mmc: data error, sending stop command
Caused by a timeout while communicating with the radio, to query
how much data is available to read if any. The timeout is likely
a hardware issue with Orange Pi Zero and other similar boards.

Signed-off-by: Georgi Valkov <gvalkov@abv.bg>
---

diff --git a/bh.c b/bh.c
index c8a7b86..6172cde 100644
--- a/bh.c
+++ b/bh.c
@@ -559,7 +559,8 @@ static int xradio_bh_rx(struct xradio_common *hw_priv, u16* nextlen) {
		goto out;
	}

-	ret = 1;
+	/* if *nextlen is 0, there are no more packets to receive */
+	ret = 1 && *nextlen;

 out:
	/* Reclaim the SKB buffer */
@@ -747,16 +748,20 @@ static int xradio_bh(void *arg)
	long status;

	for (;;) {
-		timeout = HZ / 30;
+		/* if we got awaken by interrupt last time, there is a good chance
+		 * to receive more data soon. Use the shortest sleep time in case
+		 * we miss an interrupt */
+		timeout = wake ? 1 : HZ / 30;

		// wait for something to happen or a timeout
		status = wait_event_interruptible_timeout(hw_priv->bh_wq, ( {
-					wake = atomic_xchg(&hw_priv->bh_tx, 0);
					term = kthread_should_stop();
					suspend = atomic_read(&hw_priv->bh_suspend);
+					wake = atomic_xchg(&hw_priv->bh_tx, 0);
					(wake || term || suspend);}), timeout);

		if (wake) {
+			missed = 0;
			if(xradio_bh_exchange(hw_priv) < 0){
				break;
			}
@@ -768,8 +773,18 @@ static int xradio_bh(void *arg)
					hw_priv->bh_error, status);
			break;
		} else if (!status) {
+			/* wait timed out
+			 * check if a late interrupt arrived in the last moment */
+			if (atomic_xchg(&hw_priv->bh_tx, 0))
+			{
+				wake = 1;
+				missed = 0;
+				if(xradio_bh_exchange(hw_priv) < 0){
+					break;
+				}
+			}
			/* check if there is data waiting but we missed the interrupt */
-			if (xradio_bh_rx_availlen(hw_priv) > 0) {
+			else if (xradio_bh_rx_availlen(hw_priv) > 0) {
				missed++;
				if (missed > 3) {
					xr_printk(XRADIO_DBG_WARN, "BH: missed %d consecutive interrupts!\n", missed);
@@ -793,7 +808,6 @@ static int xradio_bh(void *arg)
							timeout);
					break;
				}
-				missed = 0;
			} //else if (!txpending){
			  //if (hw_priv->powersave_enabled && !hw_priv->device_can_sleep && !atomic_read(&hw_priv->recent_scan)) {
			  //	/* Device is idle, we can go to sleep. */
diff --git a/sdio.c b/sdio.c
index cfff471..85a538a 100644
--- a/sdio.c
+++ b/sdio.c
@@ -133,8 +133,10 @@ static int xradio_probe_of(struct sdio_func *func)
	int ret;

	of_id = of_match_node(xradio_sdio_of_match_table, np);
-	if (!of_id)
+	if (!of_id) {
+		xr_printk(XRADIO_DBG_ERROR, "SDIO: xradio,xr819 not found in DTS\n");
		return -ENODEV;
+	}

	//pdev_data->family = of_id->data;

--
2.30.2
